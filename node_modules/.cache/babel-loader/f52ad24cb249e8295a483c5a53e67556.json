{"ast":null,"code":"export const STAGE_WIDTH = 12;\nexport const STAGE_HEIGHT = 20;\nexport const createStage = () => Array.from(Array(STAGE_HEIGHT), () => Array(STAGE_WIDTH).fill([0, 'clear']));\nexport const checkCollision = (player, stage, {\n  x: moveX,\n  y: moveY\n}) => {\n  // THIS IS SLOWER!!!\n  // return player.tetromino.some((row, y) =>\n  //   row.some((cell, x) => {\n  //     if (cell !== 0) {\n  //       return (\n  //         !stage[y + player.pos.y + moveY] ||\n  //         !stage[y + player.pos.y + moveY][x + player.pos.x + moveX] ||\n  //         stage[y + player.pos.y + moveY][x + player.pos.x + moveX][1] !==\n  //           'clear'\n  //       );\n  //     }\n  //     return false;\n  //   })\n  // );\n  // Using for loops to be able to return (and break). Not possible with forEach\n  for (let y = 0; y < player.tetromino.length; y += 1) {\n    for (let x = 0; x < player.tetromino[y].length; x += 1) {\n      // 1. Check that we're on an actual Tetromino cell\n      if (player.tetromino[y][x] !== 0) {\n        if ( // 2. Check that our move is inside the game areas height (y)\n        // That we're not go through bottom of the play area\n        !stage[y + player.pos.y + moveY] || // 3. Check that our move is inside the game areas width (x)\n        !stage[y + player.pos.y + moveY][x + player.pos.x + moveX] || // 4. Check that the cell wer'e moving to isn't set to clear\n        stage[y + player.pos.y + moveY][x + player.pos.x + moveX][1] !== 'clear') {\n          return true;\n        }\n      }\n    }\n  } // 5. If everything above is false\n\n\n  return false;\n};","map":{"version":3,"sources":["/Users/Gary 1/Desktop/Code stuff/資策會/專題/大專/artddict-react/src/pages/event/components/tetris/gameHelper.js"],"names":["STAGE_WIDTH","STAGE_HEIGHT","createStage","Array","from","fill","checkCollision","player","stage","x","moveX","y","moveY","tetromino","length","pos"],"mappings":"AAAA,OAAO,MAAMA,WAAW,GAAG,EAApB;AACP,OAAO,MAAMC,YAAY,GAAG,EAArB;AAEP,OAAO,MAAMC,WAAW,GAAG,MACzBC,KAAK,CAACC,IAAN,CAAWD,KAAK,CAACF,YAAD,CAAhB,EAAgC,MAC9BE,KAAK,CAACH,WAAD,CAAL,CAAmBK,IAAnB,CAAwB,CAAC,CAAD,EAAI,OAAJ,CAAxB,CADF,CADK;AAKP,OAAO,MAAMC,cAAc,GAAG,CAC5BC,MAD4B,EAE5BC,KAF4B,EAG5B;AAAEC,EAAAA,CAAC,EAAEC,KAAL;AAAYC,EAAAA,CAAC,EAAEC;AAAf,CAH4B,KAIzB;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA,OAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,MAAM,CAACM,SAAP,CAAiBC,MAArC,EAA6CH,CAAC,IAAI,CAAlD,EAAqD;AACnD,SACE,IAAIF,CAAC,GAAG,CADV,EAEEA,CAAC,GAAGF,MAAM,CAACM,SAAP,CAAiBF,CAAjB,EAAoBG,MAF1B,EAGEL,CAAC,IAAI,CAHP,EAIE;AACA;AACA,UAAIF,MAAM,CAACM,SAAP,CAAiBF,CAAjB,EAAoBF,CAApB,MAA2B,CAA/B,EAAkC;AAChC,aACE;AACA;AACA,SAACD,KAAK,CAACG,CAAC,GAAGJ,MAAM,CAACQ,GAAP,CAAWJ,CAAf,GAAmBC,KAApB,CAAN,IACA;AACA,SAACJ,KAAK,CAACG,CAAC,GAAGJ,MAAM,CAACQ,GAAP,CAAWJ,CAAf,GAAmBC,KAApB,CAAL,CACCH,CAAC,GAAGF,MAAM,CAACQ,GAAP,CAAWN,CAAf,GAAmBC,KADpB,CAFD,IAKA;AACAF,QAAAA,KAAK,CAACG,CAAC,GAAGJ,MAAM,CAACQ,GAAP,CAAWJ,CAAf,GAAmBC,KAApB,CAAL,CACEH,CAAC,GAAGF,MAAM,CAACQ,GAAP,CAAWN,CAAf,GAAmBC,KADrB,EAEE,CAFF,MAES,OAXX,EAYE;AACA,iBAAO,IAAP;AACD;AACF;AACF;AACF,GA1CE,CA2CH;;;AACA,SAAO,KAAP;AACD,CAjDM","sourcesContent":["export const STAGE_WIDTH = 12;\nexport const STAGE_HEIGHT = 20\n\nexport const createStage = () =>\n  Array.from(Array(STAGE_HEIGHT), () =>\n    Array(STAGE_WIDTH).fill([0, 'clear'])\n  )\n\nexport const checkCollision = (\n  player,\n  stage,\n  { x: moveX, y: moveY }\n) => {\n  // THIS IS SLOWER!!!\n  // return player.tetromino.some((row, y) =>\n  //   row.some((cell, x) => {\n  //     if (cell !== 0) {\n  //       return (\n  //         !stage[y + player.pos.y + moveY] ||\n  //         !stage[y + player.pos.y + moveY][x + player.pos.x + moveX] ||\n  //         stage[y + player.pos.y + moveY][x + player.pos.x + moveX][1] !==\n  //           'clear'\n  //       );\n  //     }\n  //     return false;\n  //   })\n  // );\n\n  // Using for loops to be able to return (and break). Not possible with forEach\n  for (let y = 0; y < player.tetromino.length; y += 1) {\n    for (\n      let x = 0;\n      x < player.tetromino[y].length;\n      x += 1\n    ) {\n      // 1. Check that we're on an actual Tetromino cell\n      if (player.tetromino[y][x] !== 0) {\n        if (\n          // 2. Check that our move is inside the game areas height (y)\n          // That we're not go through bottom of the play area\n          !stage[y + player.pos.y + moveY] ||\n          // 3. Check that our move is inside the game areas width (x)\n          !stage[y + player.pos.y + moveY][\n            x + player.pos.x + moveX\n          ] ||\n          // 4. Check that the cell wer'e moving to isn't set to clear\n          stage[y + player.pos.y + moveY][\n            x + player.pos.x + moveX\n          ][1] !== 'clear'\n        ) {\n          return true\n        }\n      }\n    }\n  }\n  // 5. If everything above is false\n  return false\n}"]},"metadata":{},"sourceType":"module"}