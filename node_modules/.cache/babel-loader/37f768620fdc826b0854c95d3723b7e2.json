{"ast":null,"code":"import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport ResizeObserver from \"resize-observer-polyfill\";\n\nconst getScrollParent = node => {\n  let parent = node;\n\n  while (parent = parent.parentElement) {\n    const overflowYVal = getComputedStyle(parent, null).getPropertyValue(\"overflow-y\");\n    if (parent === document.body) return window;\n    if (overflowYVal === \"auto\" || overflowYVal === \"scroll\") return parent;\n  }\n\n  return window;\n};\n\nconst offsetTill = (node, target) => {\n  let current = node;\n  let offset = 0; // If target is not an offsetParent itself, subtract its offsetTop and set correct target\n\n  if (target.firstChild && target.firstChild.offsetParent !== target) {\n    offset += node.offsetTop - target.offsetTop;\n    target = node.offsetParent;\n    offset += -node.offsetTop;\n  }\n\n  do {\n    offset += current.offsetTop;\n    current = current.offsetParent;\n  } while (current && current !== target);\n\n  return offset;\n};\n\nlet stickyProp = null;\n\nif (typeof CSS !== \"undefined\" && CSS.supports) {\n  if (CSS.supports(\"position\", \"sticky\")) stickyProp = \"sticky\";else if (CSS.supports(\"position\", \"-webkit-sticky\")) stickyProp = \"-webkit-sticky\";\n} // Inspired by https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n\n\nlet passiveArg = false;\n\ntry {\n  var opts = Object.defineProperty({}, \"passive\", {\n    // eslint-disable-next-line getter-return\n    get() {\n      passiveArg = {\n        passive: true\n      };\n    }\n\n  });\n  window.addEventListener(\"testPassive\", null, opts);\n  window.removeEventListener(\"testPassive\", null, opts);\n} catch (e) {}\n\nexport default class StickyBox extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.addListener = (element, event, handler, passive) => {\n      element.addEventListener(event, handler, passive);\n      this.unsubscribes.push(() => element.removeEventListener(event, handler));\n    };\n\n    this.addResizeObserver = (node, handler) => {\n      const ro = new ResizeObserver(handler);\n      ro.observe(node);\n      this.unsubscribes.push(() => ro.disconnect());\n    };\n\n    this.registerContainerRef = n => {\n      if (!stickyProp) return;\n      this.node = n;\n\n      if (n) {\n        this.scrollPane = getScrollParent(this.node);\n        this.latestScrollY = this.scrollPane === window ? window.scrollY : this.scrollPane.scrollTop;\n        this.addListener(this.scrollPane, \"scroll\", this.handleScroll, passiveArg);\n        this.addListener(this.scrollPane, \"mousewheel\", this.handleScroll, passiveArg);\n\n        if (this.scrollPane === window) {\n          this.addListener(window, \"resize\", this.handleWindowResize);\n          this.handleWindowResize();\n        } else {\n          this.addResizeObserver(this.scrollPane, this.handleScrollPaneResize);\n          this.handleScrollPaneResize();\n        }\n\n        this.addResizeObserver(this.node.parentNode, this.handleParentNodeResize);\n        this.handleParentNodeResize();\n        this.addResizeObserver(this.node, this.handleNodeResize);\n        this.handleNodeResize({\n          initial: true\n        });\n        this.initial();\n      } else {\n        this.unsubscribes.forEach(fn => fn());\n        this.unsubscribes = [];\n        this.scrollPane = null;\n      }\n    };\n\n    this.getCurrentOffset = () => {\n      if (this.mode === \"relative\") return this.offset;\n      const {\n        offsetTop,\n        offsetBottom\n      } = this.props;\n\n      if (this.mode === \"stickyTop\") {\n        return Math.max(0, this.scrollPaneOffset + this.latestScrollY - this.naturalTop + offsetTop);\n      }\n\n      if (this.mode === \"stickyBottom\") {\n        return Math.max(0, this.scrollPaneOffset + this.latestScrollY + this.viewPortHeight - (this.naturalTop + this.nodeHeight + offsetBottom));\n      }\n    };\n\n    this.handleWindowResize = () => {\n      this.viewPortHeight = window.innerHeight;\n      this.scrollPaneOffset = 0;\n      this.handleScroll();\n    };\n\n    this.handleScrollPaneResize = () => {\n      this.viewPortHeight = this.scrollPane.offsetHeight;\n\n      if (process.env.NODE_ENV !== \"production\" && this.viewPortHeight === 0) {\n        console.warn(`react-sticky-box's scroll pane has a height of 0. This seems odd. Please check this node:`, this.scrollPane);\n      } // Only applicable if scrollPane is an offsetParent\n\n\n      if (this.scrollPane.firstChild.offsetParent === this.scrollPane) {\n        this.scrollPaneOffset = this.scrollPane.getBoundingClientRect().top;\n      } else {\n        this.scrollPaneOffset = 0;\n      }\n\n      this.handleScroll();\n    };\n\n    this.handleParentNodeResize = () => {\n      const parentNode = this.node.parentNode;\n      const computedParentStyle = getComputedStyle(parentNode, null);\n      const parentPaddingTop = parseInt(computedParentStyle.getPropertyValue(\"padding-top\"), 10);\n      const parentPaddingBottom = parseInt(computedParentStyle.getPropertyValue(\"padding-bottom\"), 10);\n      this.naturalTop = offsetTill(parentNode, this.scrollPane) + parentPaddingTop + this.scrollPaneOffset;\n      const oldParentHeight = this.parentHeight;\n      this.parentHeight = parentNode.getBoundingClientRect().height - (parentPaddingTop + parentPaddingBottom);\n\n      if (this.mode === \"relative\") {\n        if (this.props.bottom) {\n          this.changeMode(\"relative\");\n        } else {\n          // If parent height decreased...\n          if (oldParentHeight > this.parentHeight) {\n            this.changeToStickyBottomIfBoxTooLow(this.latestScrollY);\n          }\n        }\n      }\n\n      if (oldParentHeight !== this.parentHeight && this.mode === \"relative\") {\n        this.latestScrollY = Number.POSITIVE_INFINITY;\n        this.handleScroll();\n      }\n    };\n\n    this.handleNodeResize = ({\n      initial\n    } = {}) => {\n      const prevHeight = this.nodeHeight;\n      this.nodeHeight = this.node.getBoundingClientRect().height;\n\n      if (!initial && prevHeight !== this.nodeHeight) {\n        const {\n          offsetTop,\n          offsetBottom,\n          bottom\n        } = this.props;\n\n        if (this.nodeHeight + offsetTop + offsetBottom <= this.viewPortHeight) {\n          // Just make it sticky if node smaller than viewport\n          this.mode = undefined;\n          this.initial();\n        } else {\n          const diff = prevHeight - this.nodeHeight;\n          const lowestPossible = this.parentHeight - this.nodeHeight;\n          const nextOffset = Math.min(lowestPossible, this.getCurrentOffset() + (bottom ? diff : 0));\n          this.offset = Math.max(0, nextOffset);\n          if (!bottom || this.mode !== \"stickyBottom\") this.changeMode(\"relative\");\n        }\n      }\n    };\n\n    this.handleScroll = () => {\n      const {\n        offsetTop,\n        offsetBottom\n      } = this.props;\n      const scrollY = this.scrollPane === window ? window.scrollY : this.scrollPane.scrollTop;\n      if (scrollY === this.latestScrollY) return;\n\n      if (this.nodeHeight + offsetTop + offsetBottom <= this.viewPortHeight) {\n        // Just make it sticky if node smaller than viewport\n        this.initial();\n        this.latestScrollY = scrollY;\n        return;\n      }\n\n      const scrollDelta = scrollY - this.latestScrollY;\n      this.offset = this.getCurrentOffset();\n\n      if (scrollDelta > 0) {\n        // scroll down\n        if (this.mode === \"stickyTop\") {\n          if (scrollY + this.scrollPaneOffset + offsetTop > this.naturalTop) {\n            if (scrollY + this.scrollPaneOffset + this.viewPortHeight <= this.naturalTop + this.nodeHeight + this.offset + offsetBottom) {\n              this.changeMode(\"relative\");\n            } else {\n              this.changeMode(\"stickyBottom\");\n            }\n          }\n        } else if (this.mode === \"relative\") {\n          this.changeToStickyBottomIfBoxTooLow(scrollY);\n        }\n      } else {\n        // scroll up\n        if (this.mode === \"stickyBottom\") {\n          if (this.scrollPaneOffset + scrollY + this.viewPortHeight < this.naturalTop + this.parentHeight + offsetBottom) {\n            if (this.scrollPaneOffset + scrollY + offsetTop >= this.naturalTop + this.offset) {\n              this.changeMode(\"relative\");\n            } else {\n              this.changeMode(\"stickyTop\");\n            }\n          }\n        } else if (this.mode === \"relative\") {\n          if (this.scrollPaneOffset + scrollY + offsetTop < this.naturalTop + this.offset) {\n            this.changeMode(\"stickyTop\");\n          }\n        }\n      }\n\n      this.latestScrollY = scrollY;\n    };\n\n    if (props.offset && process.env.NODE_ENV !== \"production\") {\n      console.warn(`react-sticky-box's \"offset\" prop is deprecated. Please use \"offsetTop\" instead. It'll be removed in v0.8.`);\n    }\n\n    this.unsubscribes = [];\n  }\n\n  changeMode(newMode) {\n    const {\n      onChangeMode,\n      offsetTop,\n      offsetBottom,\n      bottom\n    } = this.props;\n    if (this.mode !== newMode) onChangeMode(this.mode, newMode);\n    this.mode = newMode;\n\n    if (newMode === \"relative\") {\n      this.node.style.position = \"relative\";\n\n      if (bottom) {\n        const nextBottom = Math.max(0, this.parentHeight - this.nodeHeight - this.offset);\n        this.node.style.bottom = `${nextBottom}px`;\n      } else {\n        this.node.style.top = `${this.offset}px`;\n      }\n    } else {\n      this.node.style.position = stickyProp;\n\n      if (newMode === \"stickyBottom\") {\n        if (bottom) {\n          this.node.style.bottom = `${offsetBottom}px`;\n        } else {\n          this.node.style.top = `${this.viewPortHeight - this.nodeHeight - offsetBottom}px`;\n        }\n      } else {\n        // stickyTop\n        if (bottom) {\n          this.node.style.bottom = `${this.viewPortHeight - this.nodeHeight - offsetBottom}px`;\n        } else {\n          this.node.style.top = `${offsetTop}px`;\n        }\n      }\n    }\n\n    this.offset = this.getCurrentOffset();\n  }\n\n  initial() {\n    const {\n      bottom\n    } = this.props;\n\n    if (bottom) {\n      if (this.mode !== \"stickyBottom\") this.changeMode(\"stickyBottom\");\n    } else {\n      if (this.mode !== \"stickyTop\") this.changeMode(\"stickyTop\");\n    }\n  }\n\n  changeToStickyBottomIfBoxTooLow(scrollY) {\n    const {\n      offsetBottom\n    } = this.props;\n\n    if (scrollY + this.scrollPaneOffset + this.viewPortHeight >= this.naturalTop + this.nodeHeight + this.offset + offsetBottom) {\n      this.changeMode(\"stickyBottom\");\n    }\n  }\n\n  render() {\n    const {\n      children,\n      className,\n      style\n    } = this.props;\n    return React.createElement(\"div\", {\n      className: className,\n      style: style,\n      ref: this.registerContainerRef\n    }, children);\n  }\n\n}\nStickyBox.defaultProps = {\n  onChangeMode: () => {},\n  offsetTop: 0,\n  offsetBottom: 0\n};\nprocess.env.NODE_ENV !== \"production\" ? StickyBox.propTypes = {\n  onChangeMode: PropTypes.func,\n  offsetTop: PropTypes.number,\n  offsetBottom: PropTypes.number,\n  bottom: PropTypes.bool\n} : void 0;","map":{"version":3,"sources":["/Users/Gary 1/Desktop/Code stuff/資策會/專題/大專/artddict-react/node_modules/react-sticky-box/dist/esnext/index.js"],"names":["React","PropTypes","ResizeObserver","getScrollParent","node","parent","parentElement","overflowYVal","getComputedStyle","getPropertyValue","document","body","window","offsetTill","target","current","offset","firstChild","offsetParent","offsetTop","stickyProp","CSS","supports","passiveArg","opts","Object","defineProperty","get","passive","addEventListener","removeEventListener","e","StickyBox","Component","constructor","props","addListener","element","event","handler","unsubscribes","push","addResizeObserver","ro","observe","disconnect","registerContainerRef","n","scrollPane","latestScrollY","scrollY","scrollTop","handleScroll","handleWindowResize","handleScrollPaneResize","parentNode","handleParentNodeResize","handleNodeResize","initial","forEach","fn","getCurrentOffset","mode","offsetBottom","Math","max","scrollPaneOffset","naturalTop","viewPortHeight","nodeHeight","innerHeight","offsetHeight","process","env","NODE_ENV","console","warn","getBoundingClientRect","top","computedParentStyle","parentPaddingTop","parseInt","parentPaddingBottom","oldParentHeight","parentHeight","height","bottom","changeMode","changeToStickyBottomIfBoxTooLow","Number","POSITIVE_INFINITY","prevHeight","undefined","diff","lowestPossible","nextOffset","min","scrollDelta","newMode","onChangeMode","style","position","nextBottom","render","children","className","createElement","ref","defaultProps","propTypes","func","number","bool"],"mappings":"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","sourcesContent":["import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport ResizeObserver from \"resize-observer-polyfill\";\n\nconst getScrollParent = node => {\n  let parent = node;\n\n  while (parent = parent.parentElement) {\n    const overflowYVal = getComputedStyle(parent, null).getPropertyValue(\"overflow-y\");\n    if (parent === document.body) return window;\n    if (overflowYVal === \"auto\" || overflowYVal === \"scroll\") return parent;\n  }\n\n  return window;\n};\n\nconst offsetTill = (node, target) => {\n  let current = node;\n  let offset = 0; // If target is not an offsetParent itself, subtract its offsetTop and set correct target\n\n  if (target.firstChild && target.firstChild.offsetParent !== target) {\n    offset += node.offsetTop - target.offsetTop;\n    target = node.offsetParent;\n    offset += -node.offsetTop;\n  }\n\n  do {\n    offset += current.offsetTop;\n    current = current.offsetParent;\n  } while (current && current !== target);\n\n  return offset;\n};\n\nlet stickyProp = null;\n\nif (typeof CSS !== \"undefined\" && CSS.supports) {\n  if (CSS.supports(\"position\", \"sticky\")) stickyProp = \"sticky\";else if (CSS.supports(\"position\", \"-webkit-sticky\")) stickyProp = \"-webkit-sticky\";\n} // Inspired by https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n\n\nlet passiveArg = false;\n\ntry {\n  var opts = Object.defineProperty({}, \"passive\", {\n    // eslint-disable-next-line getter-return\n    get() {\n      passiveArg = {\n        passive: true\n      };\n    }\n\n  });\n  window.addEventListener(\"testPassive\", null, opts);\n  window.removeEventListener(\"testPassive\", null, opts);\n} catch (e) {}\n\nexport default class StickyBox extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.addListener = (element, event, handler, passive) => {\n      element.addEventListener(event, handler, passive);\n      this.unsubscribes.push(() => element.removeEventListener(event, handler));\n    };\n\n    this.addResizeObserver = (node, handler) => {\n      const ro = new ResizeObserver(handler);\n      ro.observe(node);\n      this.unsubscribes.push(() => ro.disconnect());\n    };\n\n    this.registerContainerRef = n => {\n      if (!stickyProp) return;\n      this.node = n;\n\n      if (n) {\n        this.scrollPane = getScrollParent(this.node);\n        this.latestScrollY = this.scrollPane === window ? window.scrollY : this.scrollPane.scrollTop;\n        this.addListener(this.scrollPane, \"scroll\", this.handleScroll, passiveArg);\n        this.addListener(this.scrollPane, \"mousewheel\", this.handleScroll, passiveArg);\n\n        if (this.scrollPane === window) {\n          this.addListener(window, \"resize\", this.handleWindowResize);\n          this.handleWindowResize();\n        } else {\n          this.addResizeObserver(this.scrollPane, this.handleScrollPaneResize);\n          this.handleScrollPaneResize();\n        }\n\n        this.addResizeObserver(this.node.parentNode, this.handleParentNodeResize);\n        this.handleParentNodeResize();\n        this.addResizeObserver(this.node, this.handleNodeResize);\n        this.handleNodeResize({\n          initial: true\n        });\n        this.initial();\n      } else {\n        this.unsubscribes.forEach(fn => fn());\n        this.unsubscribes = [];\n        this.scrollPane = null;\n      }\n    };\n\n    this.getCurrentOffset = () => {\n      if (this.mode === \"relative\") return this.offset;\n      const {\n        offsetTop,\n        offsetBottom\n      } = this.props;\n\n      if (this.mode === \"stickyTop\") {\n        return Math.max(0, this.scrollPaneOffset + this.latestScrollY - this.naturalTop + offsetTop);\n      }\n\n      if (this.mode === \"stickyBottom\") {\n        return Math.max(0, this.scrollPaneOffset + this.latestScrollY + this.viewPortHeight - (this.naturalTop + this.nodeHeight + offsetBottom));\n      }\n    };\n\n    this.handleWindowResize = () => {\n      this.viewPortHeight = window.innerHeight;\n      this.scrollPaneOffset = 0;\n      this.handleScroll();\n    };\n\n    this.handleScrollPaneResize = () => {\n      this.viewPortHeight = this.scrollPane.offsetHeight;\n\n      if (process.env.NODE_ENV !== \"production\" && this.viewPortHeight === 0) {\n        console.warn(`react-sticky-box's scroll pane has a height of 0. This seems odd. Please check this node:`, this.scrollPane);\n      } // Only applicable if scrollPane is an offsetParent\n\n\n      if (this.scrollPane.firstChild.offsetParent === this.scrollPane) {\n        this.scrollPaneOffset = this.scrollPane.getBoundingClientRect().top;\n      } else {\n        this.scrollPaneOffset = 0;\n      }\n\n      this.handleScroll();\n    };\n\n    this.handleParentNodeResize = () => {\n      const parentNode = this.node.parentNode;\n      const computedParentStyle = getComputedStyle(parentNode, null);\n      const parentPaddingTop = parseInt(computedParentStyle.getPropertyValue(\"padding-top\"), 10);\n      const parentPaddingBottom = parseInt(computedParentStyle.getPropertyValue(\"padding-bottom\"), 10);\n      this.naturalTop = offsetTill(parentNode, this.scrollPane) + parentPaddingTop + this.scrollPaneOffset;\n      const oldParentHeight = this.parentHeight;\n      this.parentHeight = parentNode.getBoundingClientRect().height - (parentPaddingTop + parentPaddingBottom);\n\n      if (this.mode === \"relative\") {\n        if (this.props.bottom) {\n          this.changeMode(\"relative\");\n        } else {\n          // If parent height decreased...\n          if (oldParentHeight > this.parentHeight) {\n            this.changeToStickyBottomIfBoxTooLow(this.latestScrollY);\n          }\n        }\n      }\n\n      if (oldParentHeight !== this.parentHeight && this.mode === \"relative\") {\n        this.latestScrollY = Number.POSITIVE_INFINITY;\n        this.handleScroll();\n      }\n    };\n\n    this.handleNodeResize = ({\n      initial\n    } = {}) => {\n      const prevHeight = this.nodeHeight;\n      this.nodeHeight = this.node.getBoundingClientRect().height;\n\n      if (!initial && prevHeight !== this.nodeHeight) {\n        const {\n          offsetTop,\n          offsetBottom,\n          bottom\n        } = this.props;\n\n        if (this.nodeHeight + offsetTop + offsetBottom <= this.viewPortHeight) {\n          // Just make it sticky if node smaller than viewport\n          this.mode = undefined;\n          this.initial();\n        } else {\n          const diff = prevHeight - this.nodeHeight;\n          const lowestPossible = this.parentHeight - this.nodeHeight;\n          const nextOffset = Math.min(lowestPossible, this.getCurrentOffset() + (bottom ? diff : 0));\n          this.offset = Math.max(0, nextOffset);\n          if (!bottom || this.mode !== \"stickyBottom\") this.changeMode(\"relative\");\n        }\n      }\n    };\n\n    this.handleScroll = () => {\n      const {\n        offsetTop,\n        offsetBottom\n      } = this.props;\n      const scrollY = this.scrollPane === window ? window.scrollY : this.scrollPane.scrollTop;\n      if (scrollY === this.latestScrollY) return;\n\n      if (this.nodeHeight + offsetTop + offsetBottom <= this.viewPortHeight) {\n        // Just make it sticky if node smaller than viewport\n        this.initial();\n        this.latestScrollY = scrollY;\n        return;\n      }\n\n      const scrollDelta = scrollY - this.latestScrollY;\n      this.offset = this.getCurrentOffset();\n\n      if (scrollDelta > 0) {\n        // scroll down\n        if (this.mode === \"stickyTop\") {\n          if (scrollY + this.scrollPaneOffset + offsetTop > this.naturalTop) {\n            if (scrollY + this.scrollPaneOffset + this.viewPortHeight <= this.naturalTop + this.nodeHeight + this.offset + offsetBottom) {\n              this.changeMode(\"relative\");\n            } else {\n              this.changeMode(\"stickyBottom\");\n            }\n          }\n        } else if (this.mode === \"relative\") {\n          this.changeToStickyBottomIfBoxTooLow(scrollY);\n        }\n      } else {\n        // scroll up\n        if (this.mode === \"stickyBottom\") {\n          if (this.scrollPaneOffset + scrollY + this.viewPortHeight < this.naturalTop + this.parentHeight + offsetBottom) {\n            if (this.scrollPaneOffset + scrollY + offsetTop >= this.naturalTop + this.offset) {\n              this.changeMode(\"relative\");\n            } else {\n              this.changeMode(\"stickyTop\");\n            }\n          }\n        } else if (this.mode === \"relative\") {\n          if (this.scrollPaneOffset + scrollY + offsetTop < this.naturalTop + this.offset) {\n            this.changeMode(\"stickyTop\");\n          }\n        }\n      }\n\n      this.latestScrollY = scrollY;\n    };\n\n    if (props.offset && process.env.NODE_ENV !== \"production\") {\n      console.warn(`react-sticky-box's \"offset\" prop is deprecated. Please use \"offsetTop\" instead. It'll be removed in v0.8.`);\n    }\n\n    this.unsubscribes = [];\n  }\n\n  changeMode(newMode) {\n    const {\n      onChangeMode,\n      offsetTop,\n      offsetBottom,\n      bottom\n    } = this.props;\n    if (this.mode !== newMode) onChangeMode(this.mode, newMode);\n    this.mode = newMode;\n\n    if (newMode === \"relative\") {\n      this.node.style.position = \"relative\";\n\n      if (bottom) {\n        const nextBottom = Math.max(0, this.parentHeight - this.nodeHeight - this.offset);\n        this.node.style.bottom = `${nextBottom}px`;\n      } else {\n        this.node.style.top = `${this.offset}px`;\n      }\n    } else {\n      this.node.style.position = stickyProp;\n\n      if (newMode === \"stickyBottom\") {\n        if (bottom) {\n          this.node.style.bottom = `${offsetBottom}px`;\n        } else {\n          this.node.style.top = `${this.viewPortHeight - this.nodeHeight - offsetBottom}px`;\n        }\n      } else {\n        // stickyTop\n        if (bottom) {\n          this.node.style.bottom = `${this.viewPortHeight - this.nodeHeight - offsetBottom}px`;\n        } else {\n          this.node.style.top = `${offsetTop}px`;\n        }\n      }\n    }\n\n    this.offset = this.getCurrentOffset();\n  }\n\n  initial() {\n    const {\n      bottom\n    } = this.props;\n\n    if (bottom) {\n      if (this.mode !== \"stickyBottom\") this.changeMode(\"stickyBottom\");\n    } else {\n      if (this.mode !== \"stickyTop\") this.changeMode(\"stickyTop\");\n    }\n  }\n\n  changeToStickyBottomIfBoxTooLow(scrollY) {\n    const {\n      offsetBottom\n    } = this.props;\n\n    if (scrollY + this.scrollPaneOffset + this.viewPortHeight >= this.naturalTop + this.nodeHeight + this.offset + offsetBottom) {\n      this.changeMode(\"stickyBottom\");\n    }\n  }\n\n  render() {\n    const {\n      children,\n      className,\n      style\n    } = this.props;\n    return React.createElement(\"div\", {\n      className: className,\n      style: style,\n      ref: this.registerContainerRef\n    }, children);\n  }\n\n}\nStickyBox.defaultProps = {\n  onChangeMode: () => {},\n  offsetTop: 0,\n  offsetBottom: 0\n};\nprocess.env.NODE_ENV !== \"production\" ? StickyBox.propTypes = {\n  onChangeMode: PropTypes.func,\n  offsetTop: PropTypes.number,\n  offsetBottom: PropTypes.number,\n  bottom: PropTypes.bool\n} : void 0;"]},"metadata":{},"sourceType":"module"}